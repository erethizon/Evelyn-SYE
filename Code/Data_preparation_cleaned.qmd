---
title: "Data_Preparation_edited"
author: "Evelyn Albrecht"
format: html
editor: visual
---

# Setting Up

### Clearing R's environment

```{r}
rm(list=ls())
```

### Loading relevant packages

```{r}
library(tidyverse) #bunch of packages combined to be one 
library(here) #assists in importing data sets 
library(janitor) #helps with reformating data 
```

# Data Clean-up

## Road Data

Import the data and give it a name

```{r}
roads <- read.csv(here("Data","road_total_by_buffer.csv"))
```

preview the data

```{r}
glimpse(roads)
```

### Address the lack of deployment number exporting 

The deployment numbers did not export properly. idk what happened but the way I am going to address this by merging the data with a portion of the full data from a camera.

read in the data

```{r}
cam_data <- read.csv(here("Data","full_camera_data.csv"))
```

there are 54 variables, we do not need all of them so we are going to extract the ones that we are going to use in the future and create a new dataframe

the variables we want are - deployment #\[1\], cam sd\[12\], distance(of radius of buffer. will be used to calculate the total area)\[49\]and buffer name\[54\],

lets use the select function to grab those column

FID multiring buffer = orig ID - joining things. BUT orig ID doesn't export with the full data

```{r}
cam_data_simplified <- cam_data %>%
  select(1,12,49,54)
```

####See Erika comment on Data_preparation.qmd about getting the other data from GIS

What we intend to use this data for is to determine the road density withing each buffer. Therefore we are going to need to rearrange this data so that we have a row entry per buffer and a total amount of road within it. The issue is that GIS takes takes the amount of road and segments it. It also has different entries for each of the roads that may be within the buffer. Therefore we will consolidate all of the road within a buffer into a single entry.

before we move on to getting these totals, lets rename the Shape_Leng column so that it makes more sense for our data.

merge the dataframes together

```{r}
road_density <- merge(cam_data_simplified,roads)
```

rename the column of total road length to be a more accurate descriptor

```{r}
colnames(road_density)[7] <- "road_length_m"
```

### Calculating total road area

lets ass another column with the total area of the buffer. this will be calculated using the "distance" variable

lets rename the distance variable to represent its nature first

```{r}
colnames(road_density)[4] <- "radius"
```

Now to calculate the total area

```{r}
road_density <- road_density%>% mutate(
  buffer_area_km2 = pi * radius * radius
)
```

Now calculate the road density per buffer

```{r}
road_density <- road_density %>% mutate(
  road_density_m_per_km2 = road_length_m/buffer_area_km2
)
```

finally, lets shave this data frame down to the relevant columns and export it as a new csv to save for later

```{r}
road_density <- road_density %>%
  select(1,3,10)
write.csv(road_density, here("Data","Road_density.csv"))
```

### (SKIP NOW)Calculating total amount of road per buffer

A prerequisite to any grouping is conversions of some values into factors. There are multiple variables that all represent the same thing, the buffer ID, in this dataframe. We just need to choose one to convert and use for our variable.

I will choose to convert the variable cam_buffer into a factor variable

```{r}
#roads$cam_buffer <- as.factor(roads$cam_buffer)
```

If we glimpse again we can see that it is now registered as a factor with 287 levels. Because we have a total of 516 buffers, this means that there is not necessarily a road within each buffer. This means that there will be gaps and N/As that we will have to mind when joining this dataframe(or the new one we create) to the landuse one.

Lets create a new dataframe "buffers_roads"

```{r}
#roads <- roads %>% 
    # group_by(cam_buffer) %>% mutate(
     #summarise(
      #    total_length = sum(road_length_m)
     ))
```

try and sync up some things

```{r}
#buffers <- read.csv(here("Data","Camera_buffers.csv"))
```

Our variable titled "distance" is actually just the radius (km) of the buffer. lets change the name of the variable to represent that

```{r}
#colnames(roads)[c(4)] <- "radius"
```

Now lets find the ratio of m road to square km of buffer

```{r}
#roads <- roads %>% mutate(
  #road_density = road_length_m/buffer_area_km2
)
```

I still only want the total

Lets take a quick look at this new dataframe

```{r}
#view(buffer_roads)
```

looks good now we shall export the dataframe

```{r}
#write.csv(buffer_roads, here("Data","Buffers_roads.csv"),row.names = F)# add row.names = F when you write csv files to prevent the strange "X" in column names and to prevent addition of extra columns when you read in the data
```

We now have a new csv file containing only this data. yay!

```{r}
#buffer_roads <- roads %>%
 #    group_by(cam_buffer) %>%
  #   summarise(
   #       total_length = sum(road_length_m)
     )
```

## Landuse Data

Before moving onto altering the landuse data, let's clear our environment again

```{r}
#rm(list = ls())
```

### Reading in and merging datasets

because GIS wouldnt export all 516 values in the table at once, I divided the exports into three csv files, one for fishers, one for female porcupines, and one for male porcupines. here I will merge them all together.

Read in the three datasets

```{r}
#fishers <- read.csv(here("Data","PEPE_landuse.csv"))
#porcupines_f <- read.csv(here("Data","ERDO_F_landuse.csv"))
#porcupines_m <- read.csv(here("Data","ERDO_M_landuse.csv"))
```

This has now been done- but its saved on the pc so im gonna mess with it afterwards

```{r}
#landuse <- read.csv(here("Data","landuse_fix.csv"))
```

## FIX THIS!!!

Now merge the three together

```{r}
#landuse <- merge(fishers,porcupines_f)%>%
 # merge(porcupines_m) #the piping allows for the merging three dataframes 
```

SKIP to here now

## New Dataframe from GIS

```{r}
landuse <- read.csv(here("Data","landuse_fix.csv"))
```

Now time to flip the data into the way we want it to be

try to use the t() function

```{r}
landuse_transpose <- t(landuse)
```

This is doing somewhat what I want it to do but now the first row is what the column headers should be.

Use the Janitor package to convert the first row to the column headers

```{r}
landuse_transpose_fix <- landuse_transpose %>% row_to_names(row_number = 1)
```

Change the values of the land use classes from number codes to descriptors

```{r}
colnames(landuse_transpose_fix)[1] <- "open_water"
colnames(landuse_transpose_fix)[2] <- "developed_open_space"
colnames(landuse_transpose_fix)[3] <- "developed_low_intensity"
colnames(landuse_transpose_fix)[4] <- "developed_medium_inensity"
colnames(landuse_transpose_fix)[5] <- "developed_high_intensity"
colnames(landuse_transpose_fix)[6] <- "barren_land"
colnames(landuse_transpose_fix)[7] <- "deciduous_forest"
colnames(landuse_transpose_fix)[8] <- "evergreen_forest"
colnames(landuse_transpose_fix)[9] <- "mixed_forest"
colnames(landuse_transpose_fix)[10] <- "shrub_scrub"
colnames(landuse_transpose_fix)[11] <- "grassland_herbaceous"
colnames(landuse_transpose_fix)[12] <- "pasture_hay"
colnames(landuse_transpose_fix)[13] <- "cultivated_crops"
colnames(landuse_transpose_fix)[14] <- "woody_wetlands"
colnames(landuse_transpose_fix)[15] <- "emergent_herbaceous_wetlands"

```

```{r}
write.csv(landuse_transpose_fix, here("Data","Buffers_landuse_full.csv")) 
```

## creating columns for totals and percents

clear environment for convenience

```{r}
rm(list = ls())
```

read in the data we are going to alter

```{r}
landuse <- read.csv(here("Data","Buffers_landuse_full.csv"))
```

Create a new column for the total amount of area in each buffer

```{r}
landuse <- landuse %>% mutate(total_area = rowSums(across(where(is.numeric)))) 
```

lets take a look at what we've made

```{r}
glimpse(landuse)
```

### Adding percent columns

now we see that there is a new column with the total area

now we need to create 15 more columns each representing the percent of the area that they make up.

use the mutate function to create new columns with a calculated percent of area of buffer covered by each landuse class.

```{r}
landuse <- landuse %>% mutate(
  p_open_water = (open_water/total_area)*100,
    p_developed_open_space = (developed_open_space/total_area)*100,
    p_developed_low_intesnsity = (developed_low_intensity/total_area)*100,
    p_developed_medium_inensity = (developed_medium_inensity/total_area)*100,
    p_developed_high_intensity = (developed_high_intensity/total_area)*100, 
    p_barren_land = (barren_land/total_area)*100, 
    p_deciduous_forest = (deciduous_forest/total_area)*100,
    p_evergreen_forest = (evergreen_forest/total_area)*100, 
    p_mixed_forest = (mixed_forest/total_area)*100,
    p_shrub_scrub = (shrub_scrub/total_area)*100, 
    p_grassland_herbaceous = (grassland_herbaceous/total_area)*100,
    p_pasture_hay = (pasture_hay/total_area)*100, 
    p_cultivated_crops = (cultivated_crops/total_area)*100, 
    p_woody_wetlands = (woody_wetlands/total_area)*100, 
    p_emergent_herbaceous_wetlands = (emergent_herbaceous_wetlands/total_area)*100
)
```

### Combining landuse classes

We would also like to know how much is forest and how much is developed and forest. to do this we need to add up the respective columns.

first create a new variable that is the total area of developed land and the total amount of forested land

```{r}
landuse <- landuse %>% mutate(
  total_developed = developed_open_space + developed_low_intensity + developed_medium_inensity + developed_high_intensity, 
  total_forest = deciduous_forest + evergreen_forest + mixed_forest
)
```

Now create a new column that will give us the percent of developed and forest in each buffer

```{r}
landuse <- landuse %>% mutate(
  percent_developed = (total_developed/total_area)*100, 
  percent_forest = (total_forest/total_area)*100
)
```

# Reformatting into a useable dataframe for the modeling

Right now, our dataframe entries are the buffer, but we want it to be the camera instead and the landuse category to merge with the buffer name.

I am going to experiment.

What i need to do is for each column of a camera, add the buffer to the landuse class so that there are 211 columns, the initial ID and then 6 sets of the 35 landuse data for each buffer type. I just have no clue where to even begin approaching doing that. After every 86 rows, the data needs to the data needs to be reformatted to become a new set of rows.

dataframe would go from 516 observations of 36 variables to 86 observations of 211 variables.

What if, I divided up the dataframe into 3 via slicing, changed the names and then merged them back together. until i can re-export the gis that has the camera numbers. I am going to do a little makeshift solution of adding a new column 1-86 for each of them.

lets try this.

slice the landuse dataframe to get 6 new dataframes each representing a new buffer

```{r}
fisher_max <- slice(landuse, 1:344) 
fisher_min <- slice(landuse, 345:688)
porcupine_M_max <- slice(landuse, 689:1032)
porcupine_M_min <- slice(landuse, 1033:1376)
porcupine_F_max <- slice(landuse, 1377:1720)
porcupine_F_min <- slice(landuse, 1721:2064)
```

lets also delete the first column for all of these. this is because our buffer names will now be incorporated into the column names. we will set the x column to null

Now to change the names of the columns to integrate the buffer. this is something I am googling first

```{r}
fisher_max <- fisher_max %>%
      rename_with(~str_c("PEPE_max_", .), everything()) # within the fisher_max dataframe lets rename all of the column with the string of characters "PEPE_max" sperated by,""
```

worked. Lets do it for the rest

```{r}
fisher_min <- fisher_min %>%
      rename_with(~str_c("PEPE_min_", .), everything())
porcupine_F_max <- porcupine_F_max %>%
      rename_with(~str_c("ERDO_F_max_", .), everything())
porcupine_F_min <- porcupine_F_min %>%
      rename_with(~str_c("ERDO_F_min_", .), everything())
porcupine_M_max <- porcupine_M_max %>%
      rename_with(~str_c("ERDO_M_max_", .), everything())
porcupine_M_min <- porcupine_M_min %>%
      rename_with(~str_c("ERDO_M_min_", .), everything())
```

Now we can merge all of the dataframes together! yay!

ran into an error. have to add the camera variable after changing all of the column names

now lets create a new row for each of them that just lists the number 1-86

use dyplr verb mutate to create a new column

create a new deploymen number variable using the lapply and gsub() lets start with the max fisher buffer

```{r}
fisher_max$deployment <- gsub("P2_","",fisher_max$PEPE_max_X)
```

it worked, now for the rest

```{r}
fisher_min$deployment <- gsub("P1_","",fisher_min$PEPE_min_X)

porcupine_F_max$deployment <- gsub("EF2_","",porcupine_F_max$ERDO_F_max_X)

porcupine_M_max$deployment <- gsub("EM2_","",porcupine_M_max$ERDO_M_max_X)

porcupine_F_min$deployment <- gsub("EF1_","",porcupine_F_min$ERDO_F_min_X)

porcupine_M_min$deployment <- gsub("EM1_","",porcupine_M_min$ERDO_M_min_X)


```

get rid of the old "X" for easier merging

```{r}
fisher_max$PEPE_max_X <- NULL
fisher_min$PEPE_min_X <- NULL
porcupine_F_max$ERDO_F_max_X <- NULL
porcupine_F_min$ERDO_F_min_X <- NULL
porcupine_M_max$ERDO_M_max_X <- NULL
porcupine_M_min$ERDO_M_min_X <- NULL
```

now merge the variables together

```{r}
landuse_by_camera <- merge(fisher_max, fisher_min)
landuse_by_camera <- merge(landuse_by_camera, porcupine_F_max)
landuse_by_camera <-  merge(landuse_by_camera,porcupine_F_min)
landuse_by_camera <- merge(landuse_by_camera,porcupine_M_max)
landuse_by_camera <-merge(landuse_by_camera,porcupine_M_min)
```

read in the camera data. also add metadata?

edit the camera data to be mergeable

```{r}
Camera_IDs <- read.csv(here("Data","full_camera_data.csv"))
```

we just want deployment and c

```{r}
cams_simple <- Camera_IDs %>%
  select(1,12)
```

# ERIKA HELP

now merge the full landuse with the camera IDs and save it

have both be factors so it merges

```{r}
landuse_by_camera2 <- merge(cams_simple, landuse_by_camera)
```

```{r}
write.csv(landuse_by_camera2, here("Data","landuse_covs_correct.csv"))
```

## Merging the covariates together 

clearing environment for cleanliness and read in the two relevant dataframe

```{r}
rm(list = ls())
road_density <- read.csv(here("Data","Road_density.csv"))
landuse <- read.csv(here("Data","landuse_covs_correct.csv"))
```

sort out road density

how are we going to do this

1.  create new column for datatype for buffer
2.  create function to select rows in which the entry falls into the class of a buffer
3.  change the density column name to include buffer
4.  remove everything but camsd and density
5.  repeat for each buffer
6.  merge them all together
7.  then we can merge the roads and landuse

start by creating a new column with just the buffer type using the function

```{r}
road_density$buffer <- substr(road_density$Buffer_cam, 1,3)
```

```{r}
porcupine_f_min <- road_density %>%
  slice(which(road_density$buffer == "EF1"))
```

and again for more

```{r}
porcupine_f_max <- road_density %>%
  slice(which(road_density$buffer == "EF2"))
porcupine_m_min <- road_density %>%
  slice(which(road_density$buffer == "EM1"))
porcupine_m_max <- road_density %>%
  slice(which(road_density$buffer == "EM2"))       
fisher_min <- road_density %>%
  slice(which(road_density$buffer == "P1_"))
fisher_max <- road_density %>%
  slice(which(road_density$buffer == "P2_"))
```

Change the headings of the variable to reflect the buffer nature of the road density

```{r}
colnames(porcupine_f_min)[4] <- "road_density_ERDO_F_min"
colnames(porcupine_m_min)[4] <- "road_density_ERDO_M_min"
colnames(porcupine_f_max)[4] <- "road_density_ERDO_F_max"
colnames(porcupine_m_max)[4] <- "road_density_ERDO_M_max"
colnames(fisher_min)[4] <- "road_density_PEPE_min"
colnames(fisher_max)[4] <- "road_density_PEPE_max"
```

shave down the frames

```{r}
porcupine_f_min <- porcupine_f_min %>%
  select(3,4)
porcupine_f_max <- porcupine_f_max %>%
  select(3,4)
porcupine_m_max <- porcupine_m_max %>%
  select(3,4)
porcupine_m_min <- porcupine_m_min %>%
  select(3,4)
fisher_max <- fisher_max %>%
  select(3,4)
fisher_min <- fisher_min %>%
  select(3,4)
```

bring back the simple cam data

```{r}
Camera_IDs <- read.csv(here("Data","full_camera_data.csv"))
cams_simple <- Camera_IDs %>%   select(1,12)
```

Merge

```{r}
road_densities <- merge(cams_simple,porcupine_f_min)
road_densities <- merge(road_densities,porcupine_f_max)
road_densities <- merge(road_densities,porcupine_m_max) 
road_densities <- merge(road_densities,porcupine_m_min) 
road_densities <- merge(road_densities,fisher_max)
road_densities <- merge(road_densities,fisher_min)
```

```{r}
covariates <- merge(landuse, road_densities)
```

road data is not in the perfect condition yet
